---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Relational data with dplyr

```{r}
library(tidyverse, warn.conflicts = FALSE)
```

[Relational data](https://r4ds.had.co.nz/relational-data.html):

* A collection of related tables of data.
* The relations are always defined between a pair of tables, by the keys.

```{r echo = FALSE}
# styler: off
companies = tribble(
  ~companies_id,                                 ~information,
              1,    "alpha sells solar panels and wind mills",
              2, "beta sells steel and installs solar panels",
)

categories = tribble(
  ~companies_id,       ~sector,
              1,      "energy",
              2,  "metallurgy",
              2,      "energy",
              3, "agriculture",
)
# styler: on
```

```{r echo = FALSE, message=FALSE}
library(dm)
database <- dm(companies, categories) |>
  dm_add_pk(companies, companies_id) |>
  dm_add_fk(categories, companies_id, companies)
database |> dm_draw()
```

```{r}
companies

categories

left_join(companies, categories, by = "companies_id")
```

### Mutating joins

Add new variables to one data frame from matching observations in another.

--

[Inner join](https://r4ds.had.co.nz/relational-data.html#mutating-joins): Drop unmatched rows.

```{r}
inner_join(companies, categories, by = "companies_id")
```

[Outter joins](https://r4ds.had.co.nz/relational-data.html#outer-join):

* Keep all rows in `x`

```{r}
# Most common
left_join(companies, categories, by = "companies_id")

```

* Keep all rows in `y`

```{r}
left_join(companies, categories, by = "companies_id")
```

* Keep all rows in `x` and `y`

```{r}
full_join(companies, categories, by = "companies_id")
```

* [Duplicate keys](https://r4ds.had.co.nz/relational-data.html#join-matches)

```{r}
# Duplicate keys in one table
companies2 = bind_rows(companies, tibble(companies_id = 1L, information = "abc"))
left_join(companies2, categories)

# Duplicate keys in both tables
categories2 = bind_rows(categories, tibble(companies_id = 1L, sector = "xyz"))
left_join(companies2, categories2)
```

### Filtering joins

Affect observations, not variables:

* semi_join(x, y) keeps all observations in x that have a match in y.

```{r}
semi_join(companies, categories)
```

* anti_join(x, y) drops all observations in x that have a match in y.

```{r}
# Invalid foreign key
anti_join(categories, companies)
```


### Validating keys to avoid [join problems](https://r4ds.had.co.nz/relational-data.html#join-problems)

* All values of a primary key should be unique.

```{r}
companies |>
  count(companies_id) |>
  filter(n > 1)

# (!) The `companies_id` column is NOT a primary key of `categories`
categories |>
  count(companies_id) |>
  filter(n > 1)
```

* No value of a primary key should be missing.

```{r}
companies |> 
  filter(is.na(companies_id))
```

* All values of a foreign key should match a value of a primary key.

```{r}
# ! Problem
anti_join(categories, companies, by = "companies_id")
```
