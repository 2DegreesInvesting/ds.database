---
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Relational data with dm

The dm package:

* Makes it easy to create, visualize, check, and use complex datasets.
* Plays well with dplyr.

```{r}
library(dm, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
```

Example dataset with two tables.

```{r}
companies <- tribble(
  # styler: off
  ~companies_id,                                 ~information,
              1,    "alpha sells solar panels and wind mills",
              2, "beta sells steel and installs solar panels",
  # styler: on
)

categories <- tribble(
  # styler: off
  ~companies_id,       ~sector,
              1,      "energy",
              2,  "metallurgy",
              2,      "energy",
              3, "agriculture",
  # styler: on
)
```

A data model (dm) is like a named list with special features:

```{r}
dm <- dm(companies, categories)

dm$companies

dm$categories
```

* It can store the relationships between tables via primary and foreign keys.

```{r}
# Before
dm

dm2 <- dm |>
  dm_add_pk(companies, companies_id) |>
  dm_add_fk(categories, companies_id, companies)

# After
dm2
```

* It makes it easy to draw and understand the relationship between tables.

```{r}
dm2 |>
  dm_draw()
```

* It makes it easy to examine the constraints of you data:

    * Each value of a foreign key should be unique.
    * Each value of a foreign key should not be missing.
    * Each value of a foreign key should match a value in its primary key.

```{r}
dm2 |>
  dm_examine_constraints()
```

(Doing this "by hand" with dplyr is a lot harder.)

```{r}
# Expect no duplicates
dm$companies |>
  count(companies_id) |>
  filter(n > 1)

# Expect no missing values
dm$companies |>
  filter(is.na(companies_id))

# Expect no miss-match
# Problem!
categories |>
  anti_join(companies, by = "companies_id")
```

* It allows you to manipulate tables with functions similar to dplyr's.

```{r}
# Fix constraints by excluding the bad row
dm3 <- dm2 |>
  dm_filter(categories = (companies_id != 3))

dm3 |>
  dm_examine_constraints()
```

* It makes it easy to join multiple tables.

```{r}
dm3 |>
  dm_flatten_to_tbl(categories, .recursive = TRUE)
```
